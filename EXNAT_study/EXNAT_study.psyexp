<?xml version="1.0" ?>
<PsychoPy2experiment encoding="utf-8" version="2021.2.3">
  <Settings>
    <Param name="Audio latency priority" updates="None" val="use prefs" valType="str"/>
    <Param name="Audio lib" updates="None" val="use prefs" valType="str"/>
    <Param name="Completed URL" updates="None" val="" valType="str"/>
    <Param name="Data file delimiter" updates="None" val="auto" valType="str"/>
    <Param name="Data filename" updates="None" val="u'data/%s_%s_%s' % (expInfo['participant'], expName, expInfo['date'])" valType="code"/>
    <Param name="Enable Escape" updates="None" val="True" valType="bool"/>
    <Param name="Experiment info" updates="None" val="{'participant': '', 'session': '001'}" valType="code"/>
    <Param name="Force stereo" updates="None" val="True" valType="bool"/>
    <Param name="Full-screen window" updates="None" val="True" valType="bool"/>
    <Param name="HTML path" updates="None" val="" valType="str"/>
    <Param name="Incomplete URL" updates="None" val="" valType="str"/>
    <Param name="Monitor" updates="None" val="testMonitor" valType="str"/>
    <Param name="Resources" updates="None" val="['comprehension_questions/Qs_Text1.html', 'demographics.html', 'index.html', 'informed_consent.html']" valType="fileList"/>
    <Param name="Save csv file" updates="None" val="False" valType="bool"/>
    <Param name="Save excel file" updates="None" val="False" valType="bool"/>
    <Param name="Save hdf5 file" updates="None" val="False" valType="bool"/>
    <Param name="Save log file" updates="None" val="True" valType="bool"/>
    <Param name="Save psydat file" updates="None" val="True" valType="bool"/>
    <Param name="Save wide csv file" updates="None" val="True" valType="bool"/>
    <Param name="Screen" updates="None" val="1" valType="num"/>
    <Param name="Show info dlg" updates="None" val="True" valType="bool"/>
    <Param name="Show mouse" updates="None" val="False" valType="bool"/>
    <Param name="Units" updates="None" val="height" valType="str"/>
    <Param name="Use version" updates="None" val="" valType="str"/>
    <Param name="Window size (pixels)" updates="None" val="[2560, 1440]" valType="code"/>
    <Param name="blendMode" updates="None" val="avg" valType="str"/>
    <Param name="color" updates="None" val="$[0,0,0]" valType="str"/>
    <Param name="colorSpace" updates="None" val="rgb" valType="str"/>
    <Param name="elAddress" updates="None" val="100.1.1.1" valType="str"/>
    <Param name="elDataFiltering" updates="None" val="FILTER_LEVEL_2" valType="str"/>
    <Param name="elLiveFiltering" updates="None" val="FILTER_LEVEL_OFF" valType="str"/>
    <Param name="elModel" updates="None" val="EYELINK 1000 DESKTOP" valType="str"/>
    <Param name="elPupilAlgorithm" updates="None" val="ELLIPSE_FIT" valType="str"/>
    <Param name="elPupilMeasure" updates="None" val="PUPIL_AREA" valType="str"/>
    <Param name="elSampleRate" updates="None" val="1000" valType="num"/>
    <Param name="elSimMode" updates="None" val="False" valType="bool"/>
    <Param name="elTrackEyes" updates="None" val="RIGHT_EYE" valType="str"/>
    <Param name="elTrackingMode" updates="None" val="PUPIL_CR_TRACKING" valType="str"/>
    <Param name="expName" updates="None" val="EXNAT_study" valType="str"/>
    <Param name="exportHTML" updates="None" val="on Sync" valType="str"/>
    <Param name="eyetracker" updates="None" val="None" valType="str"/>
    <Param name="gpAddress" updates="None" val="127.0.0.1" valType="str"/>
    <Param name="gpPort" updates="None" val="4242" valType="num"/>
    <Param name="logging level" updates="None" val="exp" valType="code"/>
    <Param name="mgBlink" updates="None" val="('MIDDLE_BUTTON',)" valType="list"/>
    <Param name="mgMove" updates="None" val="CONTINUOUS" valType="str"/>
    <Param name="mgSaccade" updates="None" val="0.5" valType="num"/>
    <Param name="tbLicenseFile" updates="None" val="" valType="str"/>
    <Param name="tbModel" updates="None" val="" valType="str"/>
    <Param name="tbSampleRate" updates="None" val="60" valType="num"/>
    <Param name="tbSerialNo" updates="None" val="" valType="str"/>
  </Settings>
  <Routines>
    <Routine name="settings">
      <CodeComponent name="init_JS">
        <Param name="Before Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Before JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin Experiment" updates="constant" val="// import / create functions needed to run this experiment&amp;#10;&amp;#10;// import random&amp;#10;random = Math.random;&amp;#10;console.log(&quot;imported random package&quot;);&amp;#10;&amp;#10;// from random import shuffle&amp;#10;var random_shuffle = function(array) {  &amp;#10;  var array, currentIndex = array.length, randomIndex;&amp;#10;  // While there remain elements to shuffle...&amp;#10;  while (currentIndex != 0) {&amp;#10;    // pick a random element&amp;#10;    randomIndex = Math.floor(Math.random() * currentIndex);&amp;#10;    currentIndex--;&amp;#10;    // and swap it with the current element&amp;#10;    [array[currentIndex], array[randomIndex]] = [&amp;#10;      array[randomIndex], array[currentIndex]];&amp;#10;  }&amp;#10;  // return shuffled array&amp;#10;  return array;&amp;#10;}&amp;#10;console.log(&quot;defined shuffle function&quot;)&amp;#10;&amp;#10;// np.random.uniform()&amp;#10;var uniform = function(min, max) {&amp;#10;  var min, max;&amp;#10;  return (Math.random() * (max-1 - min + 1) + min);&amp;#10;}&amp;#10;console.log(&quot;defined uniform function&quot;);&amp;#10;&amp;#10;//.append()&amp;#10;// append a value to an array&amp;#10;//var append = function(array, value){&amp;#10;//    var array, value;&amp;#10;//    return array.push(value);&amp;#10;//}&amp;#10;//console.log(&quot;defined append function&quot;);&amp;#10;// disabled because it doesn't work - use extend instead!&amp;#10;&amp;#10;// .extend()&amp;#10;// concatenate 2 arrays, return as new array&amp;#10;var extend = function(array1, array2){&amp;#10;    var array1, array2;&amp;#10;    return array1.concat(array2);&amp;#10;}&amp;#10;console.log(&quot;defined extend function&quot;);&amp;#10;&amp;#10;&amp;#10;// random.sample()&amp;#10;// this function is using the Fisher-Yates shuffle and &amp;#10;// taking a part of the resulting array to create the random sample&amp;#10;var random_sample = function(arr, k) {&amp;#10;    // with arr = some sample to draw from and k = sample size&amp;#10;    &amp;#10;    // define variables&amp;#10;    var arr, k, shuffled = arr.slice(0), i = arr.length, min = i - k, temp, index;&amp;#10;    while (i-- &gt; min) {&amp;#10;        index = Math.floor((i + 1) * Math.random());&amp;#10;        temp = shuffled[index];&amp;#10;        shuffled[index] = shuffled[i];&amp;#10;        shuffled[i] = temp;&amp;#10;    }&amp;#10;    return shuffled.slice(min);&amp;#10;}&amp;#10;console.log(&quot;defined random.sample function&quot;);&amp;#10;&amp;#10;&amp;#10;// repeat()&amp;#10;var repeat = function(value, times) {&amp;#10;    // set variables&amp;#10;    var value, times;&amp;#10;    &amp;#10;    // if you want to repeat a single value&amp;#10;    if (typeof value === 'string' || value instanceof String){&amp;#10;        // just repeat value and return as array&amp;#10;        return Array(times).fill(value); &amp;#10;    }&amp;#10;    // if you want to repeat an array&amp;#10;    else if (Array.isArray(value)){&amp;#10;        // save value array you want to append &amp; mutate the original one&amp;#10;        var add_value = value;&amp;#10;        for (var i = 0; i &lt; times-1; i++){&amp;#10;            // define variables again&amp;#10;            var array1, array2;&amp;#10;            value = extend.call(this, array1 = value, array2 = add_value);&amp;#10;        }&amp;#10;        // return concatenated arrays&amp;#10;        return value;  &amp;#10;    }&amp;#10;}&amp;#10;console.log(&quot;defined repeat function&quot;);&amp;#10;&amp;#10;// count&amp;#10;var count = function(array, value){&amp;#10;    // set variables&amp;#10;    var array, value, counter = 0, array_val;&amp;#10;    // loop array, add 1 to counter if current value matches value&amp;#10;    for (array_val of array) {&amp;#10;        if (array_val == value) {&amp;#10;            counter = counter + 1;&amp;#10;        }&amp;#10;    }&amp;#10;    return counter;&amp;#10;}&amp;#10;console.log(&quot;defined count function&quot;);&amp;#10;&amp;#10;// other stuff&amp;#10;thisExp = psychoJS.experiment;&amp;#10;win = psychoJS.window;&amp;#10;event = psychoJS.eventManager;&amp;#10;&amp;#10;&amp;#10;// range() (adapted from Becca Hirst's version)&amp;#10;var range = function(start, stop) {&amp;#10;    var start, stop;&amp;#10;    // careful, as in the Python equivalent,  &amp;#10;    // start is included in the range, stop isn't&amp;#10;    return [...Array(stop-1).keys()].map(i =&gt; i + start);&amp;#10;}&amp;#10;&amp;#10;// function to check if value is unique&amp;#10;var isUnique = function(value, index, array) {&amp;#10;    var value, index, array;&amp;#10;  return array.indexOf(value) === array.lastIndexOf(value);&amp;#10;}&amp;#10;&amp;#10;// only get unique values from array (python &quot;set&quot; function)&amp;#10;var set = function(array){&amp;#10;    var array;&amp;#10;    return array.filter(isUnique);&amp;#10;}&amp;#10;&amp;#10;" valType="extendedCode"/>
        <Param name="Begin JS Experiment" updates="constant" val="// import / create functions needed to run this experiment&amp;#10;&amp;#10;// import random&amp;#10;random = Math.random;&amp;#10;console.log(&quot;imported random package&quot;);&amp;#10;&amp;#10;// from random import shuffle&amp;#10;var random_shuffle = function(array) {  &amp;#10;  var array, currentIndex = array.length, randomIndex;&amp;#10;  // While there remain elements to shuffle...&amp;#10;  while (currentIndex != 0) {&amp;#10;    // pick a random element&amp;#10;    randomIndex = Math.floor(Math.random() * currentIndex);&amp;#10;    currentIndex--;&amp;#10;    // and swap it with the current element&amp;#10;    [array[currentIndex], array[randomIndex]] = [&amp;#10;      array[randomIndex], array[currentIndex]];&amp;#10;  }&amp;#10;  // return shuffled array&amp;#10;  return array;&amp;#10;}&amp;#10;console.log(&quot;defined shuffle function&quot;)&amp;#10;&amp;#10;// np.random.uniform()&amp;#10;var uniform = function(min, max) {&amp;#10;  var min, max;&amp;#10;  return (Math.random() * (max-1 - min + 1) + min);&amp;#10;}&amp;#10;console.log(&quot;defined uniform function&quot;);&amp;#10;&amp;#10;//.append()&amp;#10;// append a value to an array&amp;#10;//var append = function(array, value){&amp;#10;//    var array, value;&amp;#10;//    return array.push(value);&amp;#10;//}&amp;#10;//console.log(&quot;defined append function&quot;);&amp;#10;// disabled because it doesn't work - use extend instead!&amp;#10;&amp;#10;// .extend()&amp;#10;// concatenate 2 arrays, return as new array&amp;#10;var extend = function(array1, array2){&amp;#10;    var array1, array2;&amp;#10;    return array1.concat(array2);&amp;#10;}&amp;#10;console.log(&quot;defined extend function&quot;);&amp;#10;&amp;#10;&amp;#10;// random.sample()&amp;#10;// this function is using the Fisher-Yates shuffle and &amp;#10;// taking a part of the resulting array to create the random sample&amp;#10;var random_sample = function(arr, k) {&amp;#10;    // with arr = some sample to draw from and k = sample size&amp;#10;    &amp;#10;    // define variables&amp;#10;    var arr, k, shuffled = arr.slice(0), i = arr.length, min = i - k, temp, index;&amp;#10;    while (i-- &gt; min) {&amp;#10;        index = Math.floor((i + 1) * Math.random());&amp;#10;        temp = shuffled[index];&amp;#10;        shuffled[index] = shuffled[i];&amp;#10;        shuffled[i] = temp;&amp;#10;    }&amp;#10;    return shuffled.slice(min);&amp;#10;}&amp;#10;console.log(&quot;defined random.sample function&quot;);&amp;#10;&amp;#10;&amp;#10;// repeat()&amp;#10;var repeat = function(value, times) {&amp;#10;    // set variables&amp;#10;    var value, times;&amp;#10;    &amp;#10;    // if you want to repeat a single value&amp;#10;    if (typeof value === 'string' || value instanceof String){&amp;#10;        // just repeat value and return as array&amp;#10;        return Array(times).fill(value); &amp;#10;    }&amp;#10;    // if you want to repeat an array&amp;#10;    else if (Array.isArray(value)){&amp;#10;        // save value array you want to append &amp; mutate the original one&amp;#10;        var add_value = value;&amp;#10;        for (var i = 0; i &lt; times-1; i++){&amp;#10;            // define variables again&amp;#10;            var array1, array2;&amp;#10;            value = extend.call(this, array1 = value, array2 = add_value);&amp;#10;        }&amp;#10;        // return concatenated arrays&amp;#10;        return value;  &amp;#10;    }&amp;#10;}&amp;#10;console.log(&quot;defined repeat function&quot;);&amp;#10;&amp;#10;// count&amp;#10;var count = function(array, value){&amp;#10;    // set variables&amp;#10;    var array, value, counter = 0, array_val;&amp;#10;    // loop array, add 1 to counter if current value matches value&amp;#10;    for (array_val of array) {&amp;#10;        if (array_val == value) {&amp;#10;            counter = counter + 1;&amp;#10;        }&amp;#10;    }&amp;#10;    return counter;&amp;#10;}&amp;#10;console.log(&quot;defined count function&quot;);&amp;#10;&amp;#10;// other stuff&amp;#10;thisExp = psychoJS.experiment;&amp;#10;win = psychoJS.window;&amp;#10;event = psychoJS.eventManager;&amp;#10;&amp;#10;&amp;#10;// range() (adapted from Becca Hirst's version)&amp;#10;var range = function(start, stop) {&amp;#10;    var start, stop;&amp;#10;    // careful, as in the Python equivalent,  &amp;#10;    // start is included in the range, stop isn't&amp;#10;    return [...Array(stop-1).keys()].map(i =&gt; i + start);&amp;#10;}&amp;#10;&amp;#10;// function to check if value is unique&amp;#10;var isUnique = function(value, index, array) {&amp;#10;    var value, index, array;&amp;#10;  return array.indexOf(value) === array.lastIndexOf(value);&amp;#10;}&amp;#10;&amp;#10;// only get unique values from array (python &quot;set&quot; function)&amp;#10;var set = function(array){&amp;#10;    var array;&amp;#10;    return array.filter(isUnique);&amp;#10;}" valType="extendedCode"/>
        <Param name="Begin JS Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="Code Type" updates="None" val="JS" valType="str"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each JS Frame" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="disabled" updates="None" val="False" valType="bool"/>
        <Param name="name" updates="None" val="init_JS" valType="code"/>
      </CodeComponent>
      <CodeComponent name="PY_packages">
        <Param name="Before Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Before JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin Experiment" updates="constant" val="import random&amp;#10;&amp;#10;from random import shuffle as random_shuffle" valType="extendedCode"/>
        <Param name="Begin JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin JS Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="Code Type" updates="None" val="Py" valType="str"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each JS Frame" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="disabled" updates="None" val="False" valType="bool"/>
        <Param name="name" updates="None" val="PY_packages" valType="code"/>
      </CodeComponent>
      <CodeComponent name="prep_helper_functions">
        <Param name="Before Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Before JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin Experiment" updates="constant" val="# create JS-friendly custom &quot;numpy&quot; functions&amp;#10;&amp;#10;# np.min()&amp;#10;def minimum(data):&amp;#10;    min_value = data[0]&amp;#10;    for val in data:&amp;#10;        if val &lt; min_value:&amp;#10;            min_value = val&amp;#10;    return min_value&amp;#10;&amp;#10;# np.max()&amp;#10;def maximum(data):&amp;#10;    max_value = data[0]&amp;#10;    for val in data:&amp;#10;        if val &gt; max_value: max_value = val&amp;#10;    return max_value&amp;#10;&amp;#10;# np.mean&amp;#10;def mean(data): &amp;#10;    return float(sum(data)/len(data))&amp;#10;&amp;#10;# np.sqrt&amp;#10;def sqrt(N):&amp;#10;    if N &lt; 0:&amp;#10;        print(&quot;ERROR! Tried computing square root of negative number&quot;) &amp;#10;        return&amp;#10;    else:&amp;#10;        return N ** 0.5&amp;#10;&amp;#10;# np.var&amp;#10;def variance(data):&amp;#10;    mu = mean(data)&amp;#10;    variance = 0&amp;#10;    for val in data:&amp;#10;        variance = variance + (val - mu) ** 2&amp;#10;    variance = variance / len(data)&amp;#10;    return variance&amp;#10;&amp;#10;# np.std&amp;#10;def std(data):&amp;#10;    return sqrt(variance(data))&amp;#10;&amp;#10;# np.repeat&amp;#10;def repeat(value, times):&amp;#10;    new_list = []&amp;#10;    if type(value) is list:&amp;#10;        for t in range(0, times):&amp;#10;            for val in value:&amp;#10;                new_list.append(val)&amp;#10;    else:&amp;#10;        for t in range(0, times):&amp;#10;            new_list.append(value)&amp;#10;    return new_list" valType="extendedCode"/>
        <Param name="Begin JS Experiment" updates="constant" val="// create JS-friendly custom &quot;numpy&quot; functions&amp;#10;&amp;#10;// np.min()&amp;#10;var minimum = function(data) {&amp;#10;    var data, min_value = data[0];&amp;#10;    for (var val, _pj_c = 0, _pj_a = data, _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;        val = _pj_a[_pj_c];&amp;#10;        if ((val &lt; min_value)) {&amp;#10;            min_value = val;&amp;#10;        }&amp;#10;    }&amp;#10;    return min_value;&amp;#10;}&amp;#10;console.log(&quot;defined min function&quot;);&amp;#10;&amp;#10;// np.max()&amp;#10;var maximum = function(data) {&amp;#10;    var data, max_value= data[0];&amp;#10;    for (var val, _pj_c = 0, _pj_a = data, _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;        val = _pj_a[_pj_c];&amp;#10;        if ((val &gt; max_value)) {&amp;#10;            max_value = val;&amp;#10;        }&amp;#10;    }&amp;#10;    return max_value;&amp;#10;}&amp;#10;console.log(&quot;defined max function&quot;);&amp;#10;&amp;#10;// np.mean()&amp;#10;var mean = function(data) {&amp;#10;    var data;&amp;#10;    return Number.parseFloat((util.sum(data) / data.length));&amp;#10;}&amp;#10;console.log(&quot;defined mean function&quot;);&amp;#10;&amp;#10;// np.var()&amp;#10;var variance = function(data) {&amp;#10;    var data, mu = mean(data), variance = 0;&amp;#10;    for (var val, _pj_c = 0, _pj_a = data, _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;        val = _pj_a[_pj_c];&amp;#10;        variance = (variance + Math.pow((val - mu), 2));&amp;#10;    }&amp;#10;    variance = (variance / data.length);&amp;#10;    return variance;&amp;#10;}&amp;#10;console.log(&quot;defined variance function&quot;);&amp;#10;&amp;#10;// np.std()&amp;#10;var std = function(data) {&amp;#10;    var data;&amp;#10;    return sqrt(variance(data));&amp;#10;}&amp;#10;console.log(&quot;defined std function&quot;);" valType="extendedCode"/>
        <Param name="Begin JS Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="Code Type" updates="None" val="Both" valType="str"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each JS Frame" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="disabled" updates="None" val="False" valType="bool"/>
        <Param name="name" updates="None" val="prep_helper_functions" valType="code"/>
      </CodeComponent>
      <CodeComponent name="prep_nback_functions">
        <Param name="Before Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Before JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin Experiment" updates="constant" val="# function for drawing w/o replacement from list that is smaller than sample you want to draw&amp;#10;# --&gt; start over again if you run out of values, then shuffle everything&amp;#10;def draw_without_replacement(sampling_list, sample_size):&amp;#10;&amp;#10;    # repeat colour_codes_list as often as needed&amp;#10;    rep_times = round(sample_size / len(sampling_list))&amp;#10;    &amp;#10;    rep_sampling_list = list(repeat(value = sampling_list, &amp;#10;                                    times = rep_times))&amp;#10;        &amp;#10;    # check if we need some more values, if yes, draw some randomly &amp;#10;    # from colour_codes and append to our list&amp;#10;    if len(rep_sampling_list) &lt; sample_size:&amp;#10;                &amp;#10;        rep_sampling_list.extend(random.sample(sampling_list, &amp;#10;                                         k = sample_size - len(rep_sampling_list) ))&amp;#10;&amp;#10;    # now shuffle the list&amp;#10;    random.shuffle(rep_sampling_list)&amp;#10;    &amp;#10;    # return result&amp;#10;    return(list(rep_sampling_list))     &amp;#10;# END FUNCTION&amp;#10;&amp;#10;&amp;#10;&amp;#10;def create_nback_stimlist(nback_level, &amp;#10;                          colour_codes, &amp;#10;                          story, &amp;#10;                          target_abs_min, &amp;#10;                          targets_max, &amp;#10;                          targets_min,&amp;#10;                          zeroback_target = None):&amp;#10;&amp;#10;    # 1.1 chunk settings&amp;#10;    # make sure you can't repeat a colour more than 3x, so if you concatenate 2 &amp;#10;    # chunks, in the worst case you can only get the same color 6x&amp;#10;    chunk_size = len(colour_codes) * 3 &amp;#10;    &amp;#10;    # see how many whole chunks + incomplete chunks we need:&amp;#10;    chunk_nr = int(len(story) / chunk_size)&amp;#10;    chunk_missing = len(story) - chunk_size * chunk_nr&amp;#10;    &amp;#10;    # ---------------------------------------------------------------------------&amp;#10;    &amp;#10;    # 1.2 loop whole chunks&amp;#10;&amp;#10;    random_colour_list = []&amp;#10;    for chunk in range(0,chunk_nr):&amp;#10;        &amp;#10;        # There's no function to draw without replacement &amp; start over if the sample &amp;#10;        # is larger than the list of values you draw from. So I wrote my own function for this (see above). &amp;#10;        rep_colours = draw_without_replacement(sampling_list = colour_codes, &amp;#10;                                               sample_size = chunk_size)&amp;#10;        &amp;#10;        # append chunk to list&amp;#10;        random_colour_list.extend(rep_colours)&amp;#10;    &amp;#10;    # ---------------------------------------------------------------------------&amp;#10;    &amp;#10;    # 1.3 fill up colour list with missing incomplete chunk&amp;#10;    &amp;#10;    # if you need some more values to fill the list...&amp;#10;    if chunk_missing &gt; 0:&amp;#10;        &amp;#10;        # get some more random colour values as last chunk&amp;#10;        missing_chunk = draw_without_replacement(sampling_list = colour_codes, &amp;#10;                                                 sample_size = chunk_missing)&amp;#10;&amp;#10;        # also append to colour list&amp;#10;        random_colour_list.extend(missing_chunk)&amp;#10;&amp;#10;    # ---------------------------------------------------------------------------&amp;#10;    &amp;#10;    # 2. loop colour list, find &amp; count targets for the given n-back level &quot;&quot;&quot;&amp;#10;    &amp;#10;    # create empty list to collect targets / non-targets&amp;#10;    target = list()&amp;#10;&amp;#10;    for colour_idx in range(0, len(random_colour_list)):&amp;#10;        &amp;#10;        # if there are enough colours before the current colour to compare with, go on&amp;#10;        if colour_idx &gt;= nback_level:&amp;#10;            &amp;#10;            # For the 0-back, we have to compare each colour with a given target colour&amp;#10;            if nback_level == 0:&amp;#10;                curr_colour = random_colour_list[colour_idx]&amp;#10;                curr_target = curr_colour == zeroback_target&amp;#10;                &amp;#10;            # For the 1-back - 3-back, we compare each colour with one of its precedessors    &amp;#10;            else:&amp;#10;                # get current colour and the colour n times before&amp;#10;                curr_colour = random_colour_list[colour_idx]&amp;#10;                colour_before = random_colour_list[colour_idx - nback_level] &amp;#10;&amp;#10;                # compare colours: is it a match?&amp;#10;                curr_target = curr_colour == colour_before&amp;#10;               &amp;#10;            # save result in target list&amp;#10;            target.append(curr_target)&amp;#10;&amp;#10;        # if there are no colours to compare, save target as False    &amp;#10;        else:&amp;#10;            target.append(False)&amp;#10;&amp;#10;    # now check how many targets there are in our list&amp;#10;    target_count = target.count(True)&amp;#10;    &amp;#10;    # 2 things can happen now:&amp;#10;    # Thing 1 is that the colour list already has the right amount &amp;#10;    # of targets and everything's fine. This is unlikely but possible.&amp;#10;    # Thing 2 is that there are either too many or not enough targets in our colour list.&amp;#10;    # In this case, we have to take away some targets or add some without creating more targets by accident.&amp;#10;    # Example: 2-back, but we want 1 target less&amp;#10;    # b, r, r, g, o, r, o, b, r, b, g, o, o, o&amp;#10;    #                   ^        ^           ^&amp;#10;    # If we replace the first target by another letter (let's say r), &amp;#10;    # we're creating a target later in the stream by accident:&amp;#10;    # b, r, r, g, o, r, r, b, r, b, g, o, o, o&amp;#10;    #                         ^  ^           ^&amp;#10;&amp;#10;    # ---------------------------------------------------------------------------&amp;#10;    &amp;#10;    # 3. If the number of targets falls into our range... &quot;&quot;&quot;&amp;#10;    &amp;#10;    # if the number of targets falls out of our range and/or there are &amp;#10;    # less targets than needed needed, remove or add some targets&amp;#10;    &amp;#10;    # if everything's okay, save target_count as definite target number and go on:&amp;#10;    if target_count/len(target) &gt;= targets_min and target_count/len(target) &lt;= targets_max and target_count &gt;= target_abs_min:&amp;#10;&amp;#10;        target_nr = target_count&amp;#10;        &amp;#10;    &amp;#10;    elif target_count/len(target) &lt; targets_min or target_count/len(target) &gt; targets_max or target_count &lt; target_abs_min:&amp;#10;&amp;#10;     &amp;#10;        # 3.1 determine how many targets there should be&amp;#10;        &amp;#10;        found_target_nr = False&amp;#10;        while found_target_nr == False:&amp;#10;        &amp;#10;            # generate a random number of targets between targets_min and targets_max&amp;#10;            targets_percent = random.uniform(targets_min, targets_max)&amp;#10;            &amp;#10;            # check how many targets we would have in absolute numbers&amp;#10;            target_nr = round(len(story) * targets_percent)&amp;#10;            &amp;#10;            # check if this amount of targets is enough&amp;#10;            if target_nr &gt;= target_abs_min:&amp;#10;                # if yes, end while loop and keep target number&amp;#10;                found_target_nr = True&amp;#10;        &amp;#10;        # ---------------------------------------------------------------------------&amp;#10;        &amp;#10;        # 3.2 Check if there are too many or not enough targets in our list &amp; make adjustments&amp;#10;&amp;#10;        # 3.2.1 Case 1: targets missing&amp;#10;        # if there are not enough targets (aka more needed targets than targets counted) ...&amp;#10;        if target_count - target_nr &lt; 0:&amp;#10;            &amp;#10;            # check how many replacements we need to do&amp;#10;            nr_replacements = int(get_abs(target_count - target_nr))&amp;#10;            &amp;#10;            # find indices of non-targets in list &quot;target&quot; and replace by target colours, also replace False by True in &quot;target&quot; list&amp;#10;            #indices_targets = [i for i, idx in enumerate(target) if idx == False] # Careful, JS might have problems with the enumerate function and/or list comprehensions&amp;#10;            indices_targets = []&amp;#10;            for t in range(0, len(target)):&amp;#10;                if target[t] == False: &amp;#10;                    indices_targets.append(t)&amp;#10;            &amp;#10;            # select as many of them as need to be replaced, make sure not to select non-targets from the beginning of the list&amp;#10;            # --&gt; in 0-back, we don't memorize targets from former trials, so start at idx = 0 &amp;#10;            if nback_level == 0: start = 0&amp;#10;            # for every other n-back level: start at n - 1 (because python indexing starts with 0, &amp;#10;            # so start = 2 would mean we start with the 3rd element and not the 2nd)&amp;#10;            else: start = nback_level-1   &amp;#10;            &amp;#10;            idx_replacements = random.sample(indices_targets[start:len(indices_targets)], &amp;#10;                                             k = nr_replacements)&amp;#10;&amp;#10;            # loop replacements, get colour n times before the current idx, use that colour as replacement and mutate colour list&amp;#10;            for replace_this_colour in idx_replacements:&amp;#10;                &amp;#10;                # Special case 0-back: replace with target colour&amp;#10;                if nback_level == 0:&amp;#10;                    replacement_colour = zeroback_target&amp;#10;                # all other n-back levels: replace with random colour that's not the colour of the stimulus at position x+n&amp;#10;                else:&amp;#10;                    # choose colour you want to use as a replacement&amp;#10;                    replacement_colour = random_colour_list[replace_this_colour - nback_level]&amp;#10;    &amp;#10;                # now put this replacement colour in the position of the non-target you want to replace&amp;#10;                random_colour_list[replace_this_colour] = replacement_colour&amp;#10;                    &amp;#10;                # you also have a list of target positions - change that one, &amp;#10;                # too, so there's a False at the current index&amp;#10;                target[replace_this_colour] = True&amp;#10;        # ---------------------------------------------------------------------------&amp;#10;        #  3.2.2 Case 2: too many targets  &amp;#10;        # else if there are too many targets (--&gt; more targets in the list than needed)...    &amp;#10;        elif target_count - target_nr &gt; 0:&amp;#10;            &amp;#10;            # check how many replacements we need to do&amp;#10;            nr_replacements = int(get_abs(target_count - target_nr))&amp;#10;            &amp;#10;            # find indices of targets in list &quot;target&quot; and replace by non-target colours, also replace True by False in &quot;target&quot; list&amp;#10;            #indices_targets = [i for i, idx in enumerate(target) if idx == True] # Careful, JS might have problems with the enumerate function / list comprehensions&amp;#10;            indices_targets = []&amp;#10;            for t in range(0, len(target)):&amp;#10;                if target[t] == True: &amp;#10;                    indices_targets.append(t)&amp;#10;                    &amp;#10;            # select as many of them as need to be replaced&amp;#10;            idx_replacements = random.sample(indices_targets, &amp;#10;                                             k = nr_replacements)&amp;#10;&amp;#10;            # loop replacements, get colour n times after the current idx, use different colour as replacement and mutate colour list&amp;#10;            for replace_this_colour in idx_replacements:&amp;#10;                &amp;#10;                # if there is a colour n times after current idx left, make sure you use another one as a replacement&amp;#10;                if len(random_colour_list)-1 &gt;= replace_this_colour + nback_level: &amp;#10;                &amp;#10;                    # choose colour you DON'T want to use as a replacement&amp;#10;                    if nback_level == 0:&amp;#10;                        not_this_colour = zeroback_target&amp;#10;                        &amp;#10;                    else:&amp;#10;                        not_this_colour = random_colour_list[replace_this_colour + nback_level]&amp;#10;                    &amp;#10;                    # create list with colour codes that doesn't contain this value, then choose one of those randomly&amp;#10;                    colour_codes_replacements = colour_codes.copy()&amp;#10;                    colour_codes_replacements.remove(not_this_colour) &amp;#10;                    replacement_colour = random.sample(colour_codes_replacements, k = 1)[0]            &amp;#10;                &amp;#10;                # if not, you can use any colour&amp;#10;                else: replacement_colour = random.sample(colour_codes, k = 1)[0]            &amp;#10;                    &amp;#10;                # now put this replacement colour in the position of the target you want to remove&amp;#10;                random_colour_list[replace_this_colour] = replacement_colour&amp;#10;                &amp;#10;                # you also have a list of target positions - change that one, &amp;#10;                # too, so there's a False at the current index&amp;#10;                target[replace_this_colour] = False&amp;#10;&amp;#10;    # ---------------------------------------------------------------------------&amp;#10;&amp;#10;    #  4. Check output for unwanted patterns &quot;&quot;&quot;&amp;#10;    # The number of colours should be balanced (e.g. not way more blue than green),&amp;#10;    # the colours of the targets should be random (e.g. not all targets red)&amp;#10;    # and the change probabilities should be balanced (e.g. probability to change from orange to green)&amp;#10;    &amp;#10;    # We already made sure the colours are evenly distributed across the list by using our fancy chunk-sampling-system. &amp;#10;    # We changed a few colours afterwards, but I guess that should affect the distribution of the colours over the course of the trials that much.&amp;#10;    # --&gt; maybe run a simulation afterwards to check this.&amp;#10;    # In any case, we have to check the targets and the change probabilities:&amp;#10;    &amp;#10;    # 4.1 check change probabilities&amp;#10;    # find colour pairs and count their occurances&amp;#10;&amp;#10;    pairs = []&amp;#10;        &amp;#10;    for idx in range(0, len(random_colour_list) - 1):&amp;#10;&amp;#10;        # save current colour and next colour as a pair&amp;#10;        curr_colour = random_colour_list[idx] + &quot; -&gt; &quot; + random_colour_list[idx + 1]&amp;#10;        # append it to a list             &amp;#10;        pairs.append(curr_colour)&amp;#10;                &amp;#10;    # count occurances of the unique pairs&amp;#10;    colourpairs_dict = {}&amp;#10;    # loop pairs&amp;#10;    for pair in pairs:&amp;#10;        # if the current pair has an entry already, add 1 to count the occurence &amp;#10;        if pair in colourpairs_dict: &amp;#10;            colourpairs_dict[pair] = colourpairs_dict[pair] + 1&amp;#10;        # if there's no entry for the pair, create one and set occurence counter to 1&amp;#10;        else: &amp;#10;            colourpairs_dict[pair] = 1    &amp;#10;    &amp;#10;    # compute mean of occurences, if one of the change probabilities is &gt; mean + 2*SD &amp;#10;    # or &lt; mean - 2*SD, assume that change probabilities are not really balanced&amp;#10;    # compute cutoffs:&amp;#10;    change_prob_cutoff_lower = mean(list( colourpairs_dict.values() )) - 2 * std(list( colourpairs_dict.values() ))&amp;#10;    change_prob_cutoff_upper = mean(list( colourpairs_dict.values() )) + 2 * std(list( colourpairs_dict.values() ))&amp;#10;    &amp;#10;    # get min and max value to see if the data are in an okayish range&amp;#10;    min_change_prob = minimum(list(colourpairs_dict.values()))&amp;#10;    max_change_prob = maximum(list(colourpairs_dict.values()))&amp;#10;    &amp;#10;    # check if everything's fine&amp;#10;    if min_change_prob &lt; change_prob_cutoff_lower or max_change_prob &gt; change_prob_cutoff_upper:&amp;#10;        change_prob_equal = False&amp;#10;    else: change_prob_equal = True&amp;#10;&amp;#10;    # ---------------------------------------------------------------------------&amp;#10;    &amp;#10;    # 4.2 check target colour probabilities&amp;#10;    &amp;#10;    # only get targets, then count occurences for each colour&amp;#10;    #indices_targets = [idx for idx, x in enumerate(target) if x == True]&amp;#10;    indices_targets = []&amp;#10;    for t in range(0, len(target)):&amp;#10;        if target[t] == False: &amp;#10;            indices_targets.append(t)&amp;#10;    &amp;#10;    target_colours = [random_colour_list[i] for i in indices_targets]&amp;#10;    &amp;#10;    # count occurences of target colours&amp;#10;    targetcolours_dict = {}&amp;#10;    for i in target_colours:&amp;#10;        if i in targetcolours_dict: &amp;#10;            targetcolours_dict[i] += 1&amp;#10;        else: &amp;#10;            targetcolours_dict[i] = 1   &amp;#10;    &amp;#10;    # same procedure as with the change probabilities (although we don't have as many values)&amp;#10;    # compute mean of occurences, if one of the colours has a probability that is &gt; mean + 2*SD &amp;#10;    # or &lt; mean - 2*SD, assume that target probabilities are not really balanced&amp;#10;    # compute cutoffs:&amp;#10;    target_prob_cutoff_lower = mean(list( targetcolours_dict.values() )) - 2 * std( list(targetcolours_dict.values() ))&amp;#10;    target_prob_cutoff_upper = mean(list( targetcolours_dict.values() )) + 2 * std( list(targetcolours_dict.values() ))&amp;#10;    &amp;#10;    # get min and max value to see if the data are in an okayish range&amp;#10;    min_target_prob = minimum(list(targetcolours_dict.values()))&amp;#10;    max_target_prob = maximum(list(targetcolours_dict.values()))&amp;#10;    &amp;#10;    # check if everything's fine&amp;#10;    if min_target_prob &lt; target_prob_cutoff_lower or max_target_prob &gt; target_prob_cutoff_upper:&amp;#10;        target_colours_equal = False&amp;#10;    else: &amp;#10;        target_colours_equal = True&amp;#10;    &amp;#10;    # ---------------------------------------------------------------------------&amp;#10;    &amp;#10;    # 4.3 if everything's fine, return colour list and target to non-target ratio&amp;#10;    if target_colours_equal and change_prob_equal:&amp;#10;        #print(&quot;finished - returning n-back list now&quot;)&amp;#10;        return(random_colour_list, target_nr/len(target))&amp;#10;        &amp;#10;    # If not: Recursion!&amp;#10;    else: &amp;#10;        return(create_nback_stimlist(nback_level, colour_codes, story, target_abs_min, targets_max, targets_min, zeroback_target))&amp;#10;        &amp;#10;# END FUNCTION&amp;#10;&amp;#10;nback_level = 2&amp;#10;colour_codes = [&quot;red&quot;, &quot;blue&quot;, &quot;pink&quot;, &quot;violet&quot;] &amp;#10;target_abs_min = 100 &amp;#10;targets_max = 4/10 &amp;#10;targets_min = 2/12&amp;#10;story = [&quot;word&quot;] * 1000&amp;#10;zeroback_target = None&amp;#10;test = create_nback_stimlist(nback_level = nback_level, colour_codes = colour_codes, story = story, target_abs_min = target_abs_min, targets_max = targets_max, targets_min = targets_min, zeroback_target = zeroback_target)&amp;#10;" valType="extendedCode"/>
        <Param name="Begin JS Experiment" updates="constant" val="// function for drawing w/o replacement from list that is &amp;#10;// smaller than sample you want to draw&amp;#10;// --&gt; Idea: draw w/o replacement, start over again if you run out of &amp;#10;//           values, then shuffle your sample&amp;#10;// draw without replacement from list with sample size &gt; list&amp;#10;// start over again if no values left for drawing, shuffle everything in the end&amp;#10;var draw_without_replacement = function(sampling_list, sample_size) {&amp;#10;    // set variables&amp;#10;    var sampling_list, sample_size, rep_sampling_list, rep_times, value, times;&amp;#10;    // repeat colour_codes_list as often as needed&amp;#10;    rep_times = Math.floor((sample_size / sampling_list.length));&amp;#10;    rep_sampling_list = repeat.call(this, value = sampling_list, times = rep_times);&amp;#10;&amp;#10;    // check if we need some more values, if yes, draw some randomly &amp;#10;    // from colour_codes and append to our list&amp;#10;    if ((rep_sampling_list.length &lt; sample_size)) {&amp;#10;        var array1, array2, k;&amp;#10;        rep_sampling_list = extend.call(this, array1 = rep_sampling_list, array2 = random_sample.call(this, sampling_list, k = (sample_size - rep_sampling_list.length)));&amp;#10;    }&amp;#10;    // shuffle everything&amp;#10;    rep_sampling_list = random_shuffle.call(this, rep_sampling_list);&amp;#10;    return rep_sampling_list;&amp;#10;}&amp;#10;console.log(&quot;defined sample w/o replacement function&quot;);&amp;#10;&amp;#10;&amp;#10;// generate font color n-back stimulus list for given...&amp;#10;// ... n-back level (= nback_level)&amp;#10;// ... stimulus list (= colour_codes)&amp;#10;// ... words (= story)&amp;#10;// ... min. abs. number of targets (= target_abs_min)&amp;#10;// ... max. target to non-target ratio (= targets_max)&amp;#10;// ... min. target to non-target ratio (= targets_min)&amp;#10;// ﻿... zeroback target stimulus (zeroback_target = None)&amp;#10;&amp;#10;var create_nback_stimlist = function(nback_level, colour_codes, story, target_abs_min, targets_max, targets_min, zeroback_target = null) {&amp;#10;&amp;#10;  // set all variables I use in this script&amp;#10;  var nback_level, colour_codes, story, target_abs_min, targets_max, targets_min, zeroback_target,&amp;#10;  sampling_list, sample_size, rep_sampling_list, rep_times,&amp;#10;  change_prob_cutoff_lower, change_prob_cutoff_upper, change_prob_equal,&amp;#10;  chunk_missing, chunk_nr, chunk_size, colour_before, colour_codes_replacements,&amp;#10;  colourpairs_dict, curr_colour, curr_target, found_target_nr, idx_replacements,&amp;#10;  indices_targets, max_change_prob, max_target_prob, min_change_prob, min_target_prob,&amp;#10;  missing_chunk, not_this_colour, nr_replacements, pairs, random_colour_list, rep_colours,&amp;#10;  replacement_colour, start, target, target_colours, target_colours_equal, target_count,&amp;#10;  target_nr, target_prob_cutoff_lower, target_prob_cutoff_upper,&amp;#10;  targetcolours_dict, targets_percent;&amp;#10;&amp;#10;  // create pseudorandomized list of colour codes&amp;#10;  // idea: generate small random lists of colour codes with a balanced number of colours, then append them so I get an even distribution of colour codes &amp; even numbers of colour codes over the whole block&amp;#10;&amp;#10;  // chunk size should be number of distinct stimuli x 3, so there can't be more than 6x the same stimulus in a row if we concatenate 2 chunks&amp;#10;  chunk_size = colour_codes.length * 3;&amp;#10;  // given the chunk size and the number of stimuli we need, how many chunks do we need?&amp;#10;  chunk_nr = Number.parseInt(story.length / chunk_size);&amp;#10;  // check if there are still stimuli missing that we have to add at the end&amp;#10;  chunk_missing = story.length - chunk_size * chunk_nr;&amp;#10;  &amp;#10;  // placeholder for the colour list we want to create&amp;#10;  random_colour_list = [];&amp;#10;  &amp;#10;  // loop whole chunks, generate small stim list, append the lists&amp;#10;  for (var chunk = 0, _pj_a = chunk_nr; chunk &lt; _pj_a; chunk += 1) {&amp;#10;    rep_colours = draw_without_replacement.call(this, sampling_list = colour_codes, sample_size = chunk_size);&amp;#10;    random_colour_list = extend.call(this, random_colour_list, rep_colours);&amp;#10;  }&amp;#10;&amp;#10;  // if there are not enough values, randomly sample some and add them&amp;#10;  // to the end of the colour list&amp;#10;  if (chunk_missing &gt; 0) {&amp;#10;    missing_chunk = draw_without_replacement.call(this, sampling_list = colour_codes, sample_size = chunk_missing);&amp;#10;    random_colour_list = extend.call(this, random_colour_list, missing_chunk);&amp;#10;  }&amp;#10;&amp;#10;  // count how many targets there are (using the given n-back level)&amp;#10;  target =  [];&amp;#10;  &amp;#10;  // loop colour list, check if current value matches either a target stimulus (0-back) or the nth previous stimulus (1-back to 3-back)&amp;#10;  for (var colour_idx = 0, _pj_a = random_colour_list.length; colour_idx &lt; _pj_a; colour_idx += 1) {&amp;#10;    &amp;#10;    if (colour_idx &gt;= nback_level) {&amp;#10;      if (nback_level === 0) {&amp;#10;        curr_colour = random_colour_list[colour_idx];&amp;#10;        // 0-back: if the current colour is a target, save as true in curr_target&amp;#10;        curr_target = curr_colour === zeroback_target;&amp;#10;      } else {&amp;#10;        curr_colour = random_colour_list[colour_idx];&amp;#10;        colour_before = random_colour_list[colour_idx - nback_level];&amp;#10;        // 1-back to 3-back: if the current colour is a target, save as true in curr_target&amp;#10;        curr_target = curr_colour === colour_before;&amp;#10;      }&amp;#10;      // append curr_target to target list&amp;#10;      target = extend.call(this, target, curr_target);&amp;#10;    } else {&amp;#10;      // if it's not a target, save as false&amp;#10;      target = extend.call(this, target, false);&amp;#10;    }&amp;#10;  }&amp;#10;&amp;#10;  // count how many targets (aka true values) we have:&amp;#10;  var array, value;&amp;#10;  target_count = count.call(this, array = target, value = true);&amp;#10;&amp;#10;  // if we have more targets than min. target ratio and less than max. target ratio and at least the min target count, everything's fine&amp;#10;  if (target_count / target.length &gt;= targets_min &amp;&amp; target_count / target.length &lt;= targets_max &amp;&amp; target_count &gt;= target_abs_min) {&amp;#10;    target_nr = target_count;&amp;#10;  // if our target count is not in the correct range...&amp;#10;  } else {&amp;#10;    &amp;#10;    // if we don't have enough targets or too many targets...&amp;#10;    if (target_count / target.length &lt; targets_min || target_count / target.length &gt; targets_max || target_count &lt; target_abs_min) {&amp;#10;      found_target_nr = false;&amp;#10;      &amp;#10;      // randomly draw a target number to use for adding/taking away targets&amp;#10;      while (found_target_nr === false) {&amp;#10;        var min, max;&amp;#10;        targets_percent = uniform.call(this, min = targets_min, max = targets_max);&amp;#10;        target_nr = Math.floor(story.length * targets_percent);&amp;#10;        &amp;#10;        if (target_nr &gt;= target_abs_min) {&amp;#10;          found_target_nr = true;&amp;#10;        }&amp;#10;      }&amp;#10;      // if there are targets missing:&amp;#10;      if (target_count - target_nr &lt; 0) {&amp;#10;        nr_replacements = Number.parseInt(abs(target_count - target_nr));&amp;#10;        indices_targets = [];&amp;#10;        // get indices of random false values in target list&amp;#10;        for (var t = 0, _pj_a = target.length; t &lt; _pj_a; t += 1) {&amp;#10;          if (target[t] === false) {&amp;#10;            &amp;#10;            indices_targets = extend.call(this, indices_targets, t);&amp;#10;          }&amp;#10;        }&amp;#10;        // if it's a 0-back task, you can start adding targets at the first position of the colour list&amp;#10;        if (nback_level === 0) {&amp;#10;          start = 0;&amp;#10;        // if it's at least a 1-back, we have to move a few elements down the list to be able to start comparing to predecessors&amp;#10;        } else {&amp;#10;          start = nback_level - 1;&amp;#10;        }&amp;#10;        var k;&amp;#10;        idx_replacements = random_sample.call(this, indices_targets.slice(start, indices_targets.length), k =  nr_replacements);&amp;#10;        &amp;#10;        // start replacing non-targets by targets by replacing them either by a target colour or the colour n trials before&amp;#10;        for (var replace_this_colour, _pj_c = 0, _pj_a = idx_replacements, _pj_b = _pj_a.length; _pj_c &lt; _pj_b; _pj_c += 1) {&amp;#10;          replace_this_colour = _pj_a[_pj_c];&amp;#10;          &amp;#10;          // 0-back: replace non-target by target colour&amp;#10;          if (nback_level === 0) {&amp;#10;            replacement_colour = zeroback_target;&amp;#10;          // 1-back to 3-back: replace by colour from n trials before&amp;#10;          } else {&amp;#10;            replacement_colour = random_colour_list[replace_this_colour - nback_level];&amp;#10;          }&amp;#10;&amp;#10;          random_colour_list[replace_this_colour] = replacement_colour;&amp;#10;          // change non-target to target in target counter list&amp;#10;          target[replace_this_colour] = true;&amp;#10;        }&amp;#10;&amp;#10;      // too many targets, get rid of some&amp;#10;      } else {&amp;#10;        if (target_count - target_nr &gt; 0) {&amp;#10;          nr_replacements = Number.parseInt(abs(target_count - target_nr));&amp;#10;          indices_targets = [];&amp;#10;          // find indices of targets&amp;#10;          for (var t = 0, _pj_a = target.length; t &lt; _pj_a; t += 1) {&amp;#10;            &amp;#10;            if (target[t] === true) {&amp;#10;              indices_targets = extend.call(this, indices_targets, t);&amp;#10;            }&amp;#10;          }&amp;#10;          // get random indices of targets (as many as we need to replace)&amp;#10;          idx_replacements = random_sample.call(this, indices_targets, k = nr_replacements);&amp;#10;          &amp;#10;          // replace target by non-target colour (aka colour that doesn't match target colour for 0-back or target colour from n trials before (for 1-back to 3-back))&amp;#10;          for (var replace_this_colour, _pj_c = 0, _pj_a = idx_replacements, _pj_b = _pj_a.length; _pj_c &lt; _pj_b; _pj_c += 1) {&amp;#10;            replace_this_colour = _pj_a[_pj_c];&amp;#10;&amp;#10;            if (random_colour_list.length - 1 &gt;= replace_this_colour + nback_level) {&amp;#10;                &amp;#10;              if (nback_level === 0) {&amp;#10;                not_this_colour = zeroback_target;&amp;#10;              } else {&amp;#10;                not_this_colour = random_colour_list[replace_this_colour + nback_level];&amp;#10;              }&amp;#10;&amp;#10;              colour_codes_replacements = colour_codes.copy();&amp;#10;              colour_codes_replacements.remove(not_this_colour);&amp;#10;              replacement_colour = random_sample.call(this, colour_codes_replacements, k = 1)[0];&amp;#10;            } else {&amp;#10;              replacement_colour = random_sample.call(this, colour_codes, k = 1)[0];&amp;#10;            }&amp;#10;&amp;#10;            random_colour_list[replace_this_colour] = replacement_colour;&amp;#10;            target[replace_this_colour] = false;&amp;#10;          }&amp;#10;        }&amp;#10;      }&amp;#10;    }&amp;#10;  }&amp;#10;  // now check if colour transition probabilities are more or less evenly distributed&amp;#10;  var _pj;&amp;#10;&amp;#10;  var change_prob_cutoff_lower, change_prob_cutoff_upper, change_prob_equal, curr_colour, idx_pair, idx_target_colour, max_change_prob, max_target_prob, min_change_prob, min_target_prob, pairs, pairs_counter, target_colour, target_colours, target_colours_counter, target_colours_equal, target_prob_cutoff_lower, target_prob_cutoff_upper;&amp;#10;&amp;#10;  function _pj_snippets(container) {&amp;#10;    function in_es6(left, right) {&amp;#10;      if (right instanceof Array || typeof right === &quot;string&quot;) {&amp;#10;        return right.indexOf(left) &gt; -1;&amp;#10;      } else {&amp;#10;        if (right instanceof Map || right instanceof Set || right instanceof WeakMap || right instanceof WeakSet) {&amp;#10;          return right.has(left);&amp;#10;        } else {&amp;#10;          return left in right;&amp;#10;        }&amp;#10;      }&amp;#10;    }&amp;#10;&amp;#10;    container[&quot;in_es6&quot;] = in_es6;&amp;#10;    return container;&amp;#10;  }&amp;#10;&amp;#10;  _pj = {};&amp;#10;&amp;#10;  _pj_snippets(_pj);&amp;#10;&amp;#10;  pairs = [];&amp;#10;  pairs_counter = [];&amp;#10;&amp;#10;  for (var idx = 0, _pj_a = random_colour_list.length - 1; idx &lt; _pj_a; idx += 1) {&amp;#10;    curr_colour = random_colour_list[idx] + &quot; -&gt; &quot; + random_colour_list[idx + 1];&amp;#10;&amp;#10;    if (_pj.in_es6(curr_colour, pairs)) {&amp;#10;      idx_pair = pairs.index(curr_colour);&amp;#10;      pairs_counter[idx_pair] += 1;&amp;#10;    } else {&amp;#10;      extend.call(this, pairs, curr_colour);&amp;#10;      extend.call(this, pairs_counter, 1);&amp;#10;    }&amp;#10;  }&amp;#10;&amp;#10;  change_prob_cutoff_lower = mean(pairs_counter) - 2 * std(pairs_counter);&amp;#10;  change_prob_cutoff_upper = mean(pairs_counter) + 2 * std(pairs_counter);&amp;#10;  min_change_prob = minimum(pairs_counter);&amp;#10;  max_change_prob = maximum(pairs_counter);&amp;#10;&amp;#10;  if (min_change_prob &lt; change_prob_cutoff_lower || max_change_prob &gt; change_prob_cutoff_upper) {&amp;#10;    change_prob_equal = false;&amp;#10;  } else {&amp;#10;    change_prob_equal = true;&amp;#10;  }&amp;#10;&amp;#10;  target_colours = [];&amp;#10;  target_colours_counter = [];&amp;#10;&amp;#10;  for (var t = 0, _pj_a = target.length; t &lt; _pj_a; t += 1) {&amp;#10;    if (target[t] === true) {&amp;#10;      target_colour = random_colour_list[t];&amp;#10;    }&amp;#10;&amp;#10;    if (_pj.in_es6(target_colour, target_colours)) {&amp;#10;      idx_target_colour = target_colours.index(target_colour);&amp;#10;      target_colours_counter[idx_target_colour] += 1;&amp;#10;    } else {&amp;#10;      extend.call(this, target_colours, target_colour);&amp;#10;      extend.call(this, target_colours_counter, 1);&amp;#10;    }&amp;#10;  }&amp;#10;&amp;#10;  target_prob_cutoff_lower = mean(target_colours_counter) - 2 * std(target_colours_counter);&amp;#10;  target_prob_cutoff_upper = mean(target_colours_counter) + 2 * std(target_colours_counter);&amp;#10;  min_target_prob = minimum(target_colours_counter);&amp;#10;  max_target_prob = maximum(target_colours_counter);&amp;#10;&amp;#10;  if (min_target_prob &lt; target_prob_cutoff_lower || max_target_prob &gt; target_prob_cutoff_upper) {&amp;#10;    target_colours_equal = false;&amp;#10;  } else {&amp;#10;    target_colours_equal = true;&amp;#10;  }&amp;#10;&amp;#10;  // if everything's fine...&amp;#10;  if (target_colours_equal &amp;&amp; change_prob_equal) {&amp;#10;    // return colour list&amp;#10;    return random_colour_list;&amp;#10;  // if change probabilities or distribution of target colours is not balanced...&amp;#10;  } else {&amp;#10;    // recursion: generate new colour list&amp;#10;    return create_nback_stimlist(nback_level, colour_codes, story, target_abs_min, targets_max, targets_min, zeroback_target);&amp;#10;  }&amp;#10;}&amp;#10;console.log(&quot;defined nback generator function&quot;);&amp;#10;&amp;#10;&amp;#10;var story = Array(1000).fill(&quot;some_word&quot;);&amp;#10;var nback_level, colour_codes, story, target_abs_min, targets_max, targets_min, zeroback_target;&amp;#10;var test = create_nback_stimlist.call(this, nback_level = 2, colour_codes = [&quot;r&quot;, &quot;b&quot;, &quot;g&quot;, &quot;y&quot;, &quot;o&quot;], story = story, target_abs_min = 100, targets_max = 4/10, targets_min = 2/12, zeroback_target = null);&amp;#10;test = test[0]&amp;#10;console.log(&quot;defined var test&quot;);&amp;#10;" valType="extendedCode"/>
        <Param name="Begin JS Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="Code Type" updates="None" val="Both" valType="str"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each JS Frame" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="disabled" updates="None" val="False" valType="bool"/>
        <Param name="name" updates="None" val="prep_nback_functions" valType="code"/>
      </CodeComponent>
      <TextComponent name="loading1">
        <Param name="color" updates="constant" val="white" valType="color"/>
        <Param name="colorSpace" updates="constant" val="rgb" valType="str"/>
        <Param name="contrast" updates="constant" val="1" valType="num"/>
        <Param name="disabled" updates="None" val="False" valType="bool"/>
        <Param name="durationEstim" updates="None" val="" valType="num"/>
        <Param name="flip" updates="constant" val="None" valType="str"/>
        <Param name="font" updates="constant" val="Arial" valType="str"/>
        <Param name="languageStyle" updates="None" val="LTR" valType="str"/>
        <Param name="letterHeight" updates="constant" val="0.05" valType="num"/>
        <Param name="name" updates="None" val="loading1" valType="code"/>
        <Param name="opacity" updates="constant" val="" valType="num"/>
        <Param name="ori" updates="constant" val="0" valType="num"/>
        <Param name="pos" updates="constant" val="(0, 0)" valType="list"/>
        <Param name="saveStartStop" updates="None" val="False" valType="bool"/>
        <Param name="startEstim" updates="None" val="" valType="num"/>
        <Param name="startType" updates="None" val="time (s)" valType="str"/>
        <Param name="startVal" updates="None" val="0.0" valType="num"/>
        <Param name="stopType" updates="None" val="duration (s)" valType="str"/>
        <Param name="stopVal" updates="constant" val="1.0" valType="num"/>
        <Param name="syncScreenRefresh" updates="None" val="True" valType="bool"/>
        <Param name="text" updates="constant" val="Studie lädt…" valType="str"/>
        <Param name="units" updates="None" val="from exp settings" valType="str"/>
        <Param name="wrapWidth" updates="constant" val="" valType="num"/>
      </TextComponent>
    </Routine>
    <Routine name="demogr_onl">
      <TextComponent name="loading3">
        <Param name="color" updates="constant" val="white" valType="str"/>
        <Param name="colorSpace" updates="constant" val="rgb" valType="str"/>
        <Param name="contrast" updates="constant" val="1" valType="num"/>
        <Param name="disabled" updates="None" val="False" valType="bool"/>
        <Param name="durationEstim" updates="None" val="" valType="code"/>
        <Param name="flip" updates="constant" val="" valType="str"/>
        <Param name="font" updates="constant" val="Arial" valType="str"/>
        <Param name="languageStyle" updates="None" val="LTR" valType="str"/>
        <Param name="letterHeight" updates="constant" val="0.05" valType="code"/>
        <Param name="name" updates="None" val="loading3" valType="code"/>
        <Param name="opacity" updates="constant" val="1" valType="code"/>
        <Param name="ori" updates="constant" val="0" valType="code"/>
        <Param name="pos" updates="constant" val="(0, 0)" valType="code"/>
        <Param name="saveStartStop" updates="None" val="True" valType="bool"/>
        <Param name="startEstim" updates="None" val="" valType="code"/>
        <Param name="startType" updates="None" val="time (s)" valType="str"/>
        <Param name="startVal" updates="None" val="0.0" valType="code"/>
        <Param name="stopType" updates="None" val="duration (s)" valType="str"/>
        <Param name="stopVal" updates="constant" val="" valType="code"/>
        <Param name="syncScreenRefresh" updates="None" val="True" valType="bool"/>
        <Param name="text" updates="constant" val="Studie lädt…" valType="str"/>
        <Param name="units" updates="None" val="from exp settings" valType="str"/>
        <Param name="wrapWidth" updates="constant" val="" valType="code"/>
      </TextComponent>
      <CodeComponent name="iframe_2">
        <Param name="Before Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Before JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin JS Routine" updates="constant" val="// This routine should not start straight away or the screen width and height&amp;#10;// may be incorrect.&amp;#10;&amp;#10;expInfo['xRes'] = screen.width;&amp;#10;expInfo['yRes'] = screen.height;&amp;#10;console.log(&quot;screen xRes&quot;,expInfo['xRes']);&amp;#10;console.log(&quot;screen yRes&quot;,expInfo['yRes']);&amp;#10;&amp;#10;//let src = ('demographics.html?xRes='+expInfo['xRes']+'&amp;yRes='+expInfo['yRes']);&amp;#10;let src = ('demographics.html');&amp;#10;&amp;#10;params = {};  // Results added here after form is submitted&amp;#10;continue_routine = true; // Routines can't be ended from within Begin Routine&amp;#10;$(document).ready(function() {&amp;#10;    // Add custom contents from html file using an iframe:&amp;#10;    $('body').append('&lt;div id=&quot;iframe-o&quot; style=&quot;visibility: hidden; position: relative; display: table; margin: auto; overflow-x: hidden; overflow-y: scroll !important; -webkit-overflow-y-scrolling:touch !important;&quot;&gt;&lt;div id=&quot;iframe-m&quot; style=&quot;display: table-cell; vertical-align: middle;&quot;&gt;&lt;div id=&quot;iframe-i&quot; style=&quot;display: inline-block; width:100%; overflow-y: hidden; overflow-x: hidden;&quot;&gt;&lt;iframe id=&quot;iframe&quot; src=&quot;'+src+'&quot; frameborder=&quot;0&quot; style=&quot;width: 100%; overflow-y: hidden; overflow-x: hidden; &quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;');&amp;#10;    $('#iframe').on('load',function(iframe){&amp;#10;        // Auto-adjust iframe size:&amp;#10;        $(this).contents().find('html').css({ 'display': 'table', 'width': '100%', 'overflow-x': 'hidden' });&amp;#10;        $('#iframe-o').height($(window).height()-20, true);&amp;#10;        $('#iframe-m').width($(this).contents().find('html').width()+100);&amp;#10;       $('#iframe-i').height ( Math.max ( $(this).contents().find('html').height()+20, $(window).height()-20 ), true );&amp;#10;        $(this).height($(this).contents().find('html').height());&amp;#10;        $('#iframe-o').css('visibility','visible');&amp;#10;&amp;#10;        // If iframe contains a form, then capture its output:&amp;#10;        $(this).contents().find('form').on('submit',function(e){&amp;#10;            e.preventDefault();&amp;#10;            $.each($(this).serializeArray(),function(i, param){&amp;#10;                params[param.name] = param.value;&amp;#10;                psychoJS.experiment.addData(param.name, param.value);&amp;#10;            });&amp;#10;            console.log ( 'DEBUG:FRM', params );&amp;#10;            // Remove iframe and continue to next routine when done:&amp;#10;            $('#iframe-o').remove();&amp;#10;            continue_routine = false;&amp;#10;        });&amp;#10;    });&amp;#10;});&amp;#10;//$('#iframe').attr( 'src', function(i,val){ return val;} );" valType="extendedCode"/>
        <Param name="Begin Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="Code Type" updates="None" val="JS" valType="str"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each JS Frame" updates="constant" val="continueRoutine = continue_routine;" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Routine" updates="constant" val="// expInfo variables appear on every line in the data file&amp;#10;// after they are created.&amp;#10;expInfo['ID'] = psychoJS.experiment._currentTrialData['ID'];&amp;#10;expInfo['gender'] = psychoJS.experiment._currentTrialData['gender'];&amp;#10;expInfo['age'] = psychoJS.experiment._currentTrialData['age'];&amp;#10;&amp;#10;expInfo['native_speaker'] = psychoJS.experiment._currentTrialData['native_speaker'];&amp;#10;expInfo['literacy'] = psychoJS.experiment._currentTrialData['literacy'];&amp;#10;expInfo['dyslexia'] = psychoJS.experiment._currentTrialData['dyslexia'];&amp;#10;expInfo['reading_freq'] = psychoJS.experiment._currentTrialData['reading_freq'];&amp;#10;expInfo['reading_joy'] = psychoJS.experiment._currentTrialData['reading_joy'];&amp;#10;&amp;#10;expInfo['handedness'] = psychoJS.experiment._currentTrialData['handedness'];&amp;#10;&amp;#10;expInfo['impaired_eyesight'] = psychoJS.experiment._currentTrialData['impaired_eyesight'];&amp;#10;expInfo['impaired_eyesight_correction'] = psychoJS.experiment._currentTrialData['impaired_eyesight_correction'];&amp;#10;expInfo['colour_blindness'] = psychoJS.experiment._currentTrialData['colour_blindness'];&amp;#10;&amp;#10;expInfo['disease'] = psychoJS.experiment._currentTrialData['disease'];&amp;#10;expInfo['drugs_last_month'] = psychoJS.experiment._currentTrialData['drugs_last_month'];&amp;#10;expInfo['alcohol_drugs_now'] = psychoJS.experiment._currentTrialData['alcohol_drugs_now'];&amp;#10;&amp;#10;expInfo['tired'] = psychoJS.experiment._currentTrialData['tired'];&amp;#10;expInfo['distractions'] = psychoJS.experiment._currentTrialData['distractions'];" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="disabled" updates="None" val="False" valType="bool"/>
        <Param name="name" updates="None" val="iframe_2" valType="code"/>
      </CodeComponent>
    </Routine>
    <Routine name="end_excluded">
      <CodeComponent name="skip_if_included">
        <Param name="Before Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Before JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin JS Experiment" updates="constant" val="&amp;#10;&amp;#10;" valType="extendedCode"/>
        <Param name="Begin JS Routine" updates="constant" val="// skip this component if participant &amp;#10;// is eligible to participate in the study&amp;#10;&amp;#10;// get some of the &quot;hard&quot; exclusion criteria&amp;#10;var age_minor = (expInfo[&quot;age&quot;] &lt; 18);&amp;#10;var non_native = (expInfo[&quot;native_speaker&quot;] === false);&amp;#10;var illiteracy = (expInfo[&quot;literacy&quot;] === false);&amp;#10;var dyslexia = (expInfo[&quot;dyslexia&quot;] === true);&amp;#10;var colourblind = (expInfo[&quot;colour_blindness&quot;] === true);&amp;#10;var disease = (expInfo[&quot;disease&quot;] === true);&amp;#10;var drugs1 = (expInfo[&quot;drugs_last_month&quot;] === true);&amp;#10;var drugs2 = (expInfo[&quot;alcohol_drugs_now&quot;] === true);&amp;#10;&amp;#10;var excl_criteria = [age_minor, non_native, illiteracy, dyslexia, colourblind, disease, drugs1, drugs2];&amp;#10;&amp;#10;// skip routine if any of the exclusion criteria apply&amp;#10;var excl_criteria = [age_minor, non_native, illiteracy, dyslexia, colourblind, disease, drugs1, drugs2];&amp;#10;var show_this_slide = false;&amp;#10;for (var criterium, _pj_c = 0, _pj_a = excl_criteria, _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;    criterium = _pj_a[_pj_c];&amp;#10;    if ((criterium === true)) {&amp;#10;        show_this_slide = true;&amp;#10;    } &amp;#10;}&amp;#10;&amp;#10;if ((show_this_slide === false)) {&amp;#10;        continueRoutine = false;&amp;#10;    } else {&amp;#10;        continueRoutine = true;&amp;#10;    }" valType="extendedCode"/>
        <Param name="Begin Routine" updates="constant" val="#skip this component if participant &amp;#10;# is eligible to participate in the study&amp;#10;&amp;#10;# get some of the &quot;hard&quot; exclusion criteria&amp;#10;age_minor = expInfo['age'] &lt; 18&amp;#10;non_native = expInfo['native_speaker'] == False&amp;#10;illiteracy = expInfo['literacy'] == False&amp;#10;dyslexia = expInfo['dyslexia'] == True&amp;#10;colourblind = expInfo['colour_blindness'] == True&amp;#10;disease = expInfo['disease'] == True&amp;#10;drugs1 = expInfo['drugs_last_month'] == True&amp;#10;drugs2 = expInfo['alcohol_drugs_now'] == True&amp;#10;&amp;#10;# skip routine if none of the exclusion criteria apply&amp;#10;if any([age_minor, non_native, illiteracy,dyslexia, colourblind, disease, drugs1, drugs2]) == True:&amp;#10;    continueRoutine = True&amp;#10;else: continueRoutine = False&amp;#10;&amp;#10;" valType="extendedCode"/>
        <Param name="Code Type" updates="None" val="Both" valType="str"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each JS Frame" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="disabled" updates="None" val="False" valType="bool"/>
        <Param name="name" updates="None" val="skip_if_included" valType="code"/>
      </CodeComponent>
      <TextComponent name="end2">
        <Param name="color" updates="constant" val="white" valType="color"/>
        <Param name="colorSpace" updates="constant" val="rgb" valType="str"/>
        <Param name="contrast" updates="constant" val="1" valType="num"/>
        <Param name="disabled" updates="None" val="False" valType="bool"/>
        <Param name="durationEstim" updates="None" val="" valType="code"/>
        <Param name="flip" updates="constant" val="None" valType="str"/>
        <Param name="font" updates="constant" val="Arial" valType="str"/>
        <Param name="languageStyle" updates="None" val="LTR" valType="str"/>
        <Param name="letterHeight" updates="constant" val="0.05" valType="num"/>
        <Param name="name" updates="None" val="end2" valType="code"/>
        <Param name="opacity" updates="constant" val="" valType="num"/>
        <Param name="ori" updates="constant" val="0" valType="num"/>
        <Param name="pos" updates="constant" val="(0, 0)" valType="list"/>
        <Param name="saveStartStop" updates="None" val="True" valType="bool"/>
        <Param name="startEstim" updates="None" val="" valType="code"/>
        <Param name="startType" updates="None" val="time (s)" valType="str"/>
        <Param name="startVal" updates="None" val="0.0" valType="code"/>
        <Param name="stopType" updates="None" val="duration (s)" valType="str"/>
        <Param name="stopVal" updates="constant" val="" valType="code"/>
        <Param name="syncScreenRefresh" updates="None" val="True" valType="bool"/>
        <Param name="text" updates="set every repeat" val="Vielen Dank für Ihr Interesse an unserer Studie!&amp;#10;&amp;#10;Leider erfüllen Sie nicht alle Teilnahmekriterien. &amp;#10;&amp;#10;Sie können dieses Fenster nun schließen." valType="str"/>
        <Param name="units" updates="None" val="from exp settings" valType="str"/>
        <Param name="wrapWidth" updates="constant" val="" valType="num"/>
      </TextComponent>
    </Routine>
    <Routine name="instr_1">
      <TextComponent name="text">
        <Param name="color" updates="constant" val="white" valType="str"/>
        <Param name="colorSpace" updates="constant" val="rgb" valType="str"/>
        <Param name="contrast" updates="constant" val="1" valType="num"/>
        <Param name="disabled" updates="None" val="False" valType="bool"/>
        <Param name="durationEstim" updates="None" val="" valType="code"/>
        <Param name="flip" updates="constant" val="" valType="str"/>
        <Param name="font" updates="constant" val="Arial" valType="str"/>
        <Param name="languageStyle" updates="None" val="LTR" valType="str"/>
        <Param name="letterHeight" updates="constant" val="0.05" valType="code"/>
        <Param name="name" updates="None" val="text" valType="code"/>
        <Param name="opacity" updates="constant" val="1" valType="code"/>
        <Param name="ori" updates="constant" val="0" valType="code"/>
        <Param name="pos" updates="constant" val="(0, 0)" valType="code"/>
        <Param name="saveStartStop" updates="None" val="True" valType="bool"/>
        <Param name="startEstim" updates="None" val="" valType="code"/>
        <Param name="startType" updates="None" val="time (s)" valType="str"/>
        <Param name="startVal" updates="None" val="0.0" valType="code"/>
        <Param name="stopType" updates="None" val="duration (s)" valType="str"/>
        <Param name="stopVal" updates="constant" val="" valType="code"/>
        <Param name="syncScreenRefresh" updates="None" val="True" valType="bool"/>
        <Param name="text" updates="set every repeat" val="Vielen Dank für Ihr Interesse an unserer Studie! &amp;#10;&amp;#10;—&gt; Instructions for training go here" valType="extendedStr"/>
        <Param name="units" updates="None" val="norm" valType="str"/>
        <Param name="wrapWidth" updates="constant" val="" valType="code"/>
      </TextComponent>
    </Routine>
    <Routine name="consent_onl">
      <TextComponent name="loading2">
        <Param name="color" updates="constant" val="white" valType="color"/>
        <Param name="colorSpace" updates="constant" val="rgb" valType="str"/>
        <Param name="contrast" updates="constant" val="1" valType="num"/>
        <Param name="disabled" updates="None" val="False" valType="bool"/>
        <Param name="durationEstim" updates="None" val="" valType="code"/>
        <Param name="flip" updates="constant" val="None" valType="str"/>
        <Param name="font" updates="constant" val="Arial" valType="str"/>
        <Param name="languageStyle" updates="None" val="LTR" valType="str"/>
        <Param name="letterHeight" updates="constant" val="0.05" valType="num"/>
        <Param name="name" updates="None" val="loading2" valType="code"/>
        <Param name="opacity" updates="constant" val="" valType="num"/>
        <Param name="ori" updates="constant" val="0" valType="num"/>
        <Param name="pos" updates="constant" val="(0, 0)" valType="list"/>
        <Param name="saveStartStop" updates="None" val="True" valType="bool"/>
        <Param name="startEstim" updates="None" val="" valType="code"/>
        <Param name="startType" updates="None" val="time (s)" valType="str"/>
        <Param name="startVal" updates="None" val="0.0" valType="code"/>
        <Param name="stopType" updates="None" val="duration (s)" valType="str"/>
        <Param name="stopVal" updates="constant" val="" valType="code"/>
        <Param name="syncScreenRefresh" updates="None" val="True" valType="bool"/>
        <Param name="text" updates="constant" val="Studie lädt…" valType="str"/>
        <Param name="units" updates="None" val="from exp settings" valType="str"/>
        <Param name="wrapWidth" updates="constant" val="" valType="num"/>
      </TextComponent>
      <CodeComponent name="iframe_1">
        <Param name="Before Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Before JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin Experiment" updates="constant" val="// This routine should not start straight away or the screen width and height&amp;#10;// may be incorrect.&amp;#10;&amp;#10;expInfo['xRes'] = screen.width;&amp;#10;expInfo['yRes'] = screen.height;&amp;#10;console.log(&quot;screen xRes&quot;,expInfo['xRes']);&amp;#10;console.log(&quot;screen yRes&quot;,expInfo['yRes']);&amp;#10;&amp;#10;//let src = ('demographics.html?xRes='+expInfo['xRes']+'&amp;yRes='+expInfo['yRes']);&amp;#10;let src = ('demographics.html');&amp;#10;&amp;#10;params = {};  // Results added here after form is submitted&amp;#10;continue_routine = true; // Routines can't be ended from within Begin Routine&amp;#10;$(document).ready(function() {&amp;#10;    // Add custom contents from html file using an iframe:&amp;#10;    $('body').append('&lt;div id=&quot;iframe-o&quot; style=&quot;visibility: hidden; position: relative; display: table; margin: auto; overflow-x: hidden; overflow-y: scroll !important; -webkit-overflow-y-scrolling:touch !important;&quot;&gt;&lt;div id=&quot;iframe-m&quot; style=&quot;display: table-cell; vertical-align: middle;&quot;&gt;&lt;div id=&quot;iframe-i&quot; style=&quot;display: inline-block; width:100%; overflow-y: hidden; overflow-x: hidden;&quot;&gt;&lt;iframe id=&quot;iframe&quot; src=&quot;'+src+'&quot; frameborder=&quot;0&quot; style=&quot;width: 100%; overflow-y: hidden; overflow-x: hidden; &quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;');&amp;#10;    $('#iframe').on('load',function(iframe){&amp;#10;        // Auto-adjust iframe size:&amp;#10;        $(this).contents().find('html').css({ 'display': 'table', 'width': '100%', 'overflow-x': 'hidden' });&amp;#10;        $('#iframe-o').height($(window).height()-20, true);&amp;#10;        $('#iframe-m').width($(this).contents().find('html').width()+100);&amp;#10;       $('#iframe-i').height ( Math.max ( $(this).contents().find('html').height()+20, $(window).height()-20 ), true );&amp;#10;        $(this).height($(this).contents().find('html').height());&amp;#10;        $('#iframe-o').css('visibility','visible');&amp;#10;&amp;#10;        // If iframe contains a form, then capture its output:&amp;#10;        $(this).contents().find('form').on('submit',function(e){&amp;#10;            e.preventDefault();&amp;#10;            $.each($(this).serializeArray(),function(i, param){&amp;#10;                params[param.name] = param.value;&amp;#10;                psychoJS.experiment.addData(param.name, param.value);&amp;#10;            });&amp;#10;            console.log ( 'DEBUG:FRM', params );&amp;#10;            // Remove iframe and continue to next routine when done:&amp;#10;            $('#iframe-o').remove();&amp;#10;            continue_routine = false;&amp;#10;        });&amp;#10;    });&amp;#10;});&amp;#10;//$('#iframe').attr( 'src', function(i,val){ return val;} );" valType="extendedCode"/>
        <Param name="Begin JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin JS Routine" updates="constant" val="// This routine should not start straight away or the screen width and height&amp;#10;// may be incorrect.&amp;#10;&amp;#10;expInfo['xRes'] = screen.width;&amp;#10;expInfo['yRes'] = screen.height;&amp;#10;console.log(&quot;screen xRes&quot;,expInfo['xRes']);&amp;#10;console.log(&quot;screen yRes&quot;,expInfo['yRes']);&amp;#10;&amp;#10;//let src = ('demographics.html?xRes='+expInfo['xRes']+'&amp;yRes='+expInfo['yRes']);&amp;#10;let src = ('informed_consent.html');&amp;#10;&amp;#10;params = {};  // Results added here after form is submitted&amp;#10;continue_routine = true; // Routines can't be ended from within Begin Routine&amp;#10;$(document).ready(function() {&amp;#10;    // Add custom contents from html file using an iframe:&amp;#10;    $('body').append('&lt;div id=&quot;iframe-o&quot; style=&quot;visibility: hidden; position: relative; display: table; margin: auto; overflow-x: hidden; overflow-y: scroll !important; -webkit-overflow-y-scrolling:touch !important;&quot;&gt;&lt;div id=&quot;iframe-m&quot; style=&quot;display: table-cell; vertical-align: middle;&quot;&gt;&lt;div id=&quot;iframe-i&quot; style=&quot;display: inline-block; width:100%; overflow-y: hidden; overflow-x: hidden;&quot;&gt;&lt;iframe id=&quot;iframe&quot; src=&quot;'+src+'&quot; frameborder=&quot;0&quot; style=&quot;width: 100%; overflow-y: hidden; overflow-x: hidden; &quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;');&amp;#10;    $('#iframe').on('load',function(iframe){&amp;#10;        // Auto-adjust iframe size:&amp;#10;        $(this).contents().find('html').css({ 'display': 'table', 'width': '100%', 'overflow-x': 'hidden' });&amp;#10;        $('#iframe-o').height($(window).height()-20, true);&amp;#10;        $('#iframe-m').width($(this).contents().find('html').width()+100);&amp;#10;       $('#iframe-i').height ( Math.max ( $(this).contents().find('html').height()+20, $(window).height()-20 ), true );&amp;#10;        $(this).height($(this).contents().find('html').height());&amp;#10;        $('#iframe-o').css('visibility','visible');&amp;#10;&amp;#10;        // If iframe contains a form, then capture its output:&amp;#10;        $(this).contents().find('form').on('submit',function(e){&amp;#10;            e.preventDefault();&amp;#10;            $.each($(this).serializeArray(),function(i, param){&amp;#10;                params[param.name] = param.value;&amp;#10;                psychoJS.experiment.addData(param.name, param.value);&amp;#10;            });&amp;#10;            console.log ( 'DEBUG:FRM', params );&amp;#10;            // Remove iframe and continue to next routine when done:&amp;#10;            $('#iframe-o').remove();&amp;#10;            continue_routine = false;&amp;#10;        });&amp;#10;    });&amp;#10;});&amp;#10;//$('#iframe').attr( 'src', function(i,val){ return val;} );" valType="extendedCode"/>
        <Param name="Begin Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="Code Type" updates="None" val="JS" valType="str"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each JS Frame" updates="constant" val="continueRoutine = continue_routine;" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Routine" updates="constant" val="// expInfo variables appear on every line in the data file&amp;#10;// after they are created.&amp;#10;expInfo['consent'] = psychoJS.experiment._currentTrialData['consent'];&amp;#10;" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="disabled" updates="None" val="False" valType="bool"/>
        <Param name="name" updates="None" val="iframe_1" valType="code"/>
      </CodeComponent>
    </Routine>
    <Routine name="end_no_consent">
      <CodeComponent name="skip_if_consented">
        <Param name="Before Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Before JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="Begin JS Routine" updates="constant" val="console.log(&quot;starting routine end_no_consent&quot;);&amp;#10;if ((expInfo[&quot;consent&quot;] === false)) {&amp;#10;    console.log(&quot;continue routine&quot;);&amp;#10;    continueRoutine = true;&amp;#10;} else {&amp;#10;    console.log(&quot;end routine&quot;);&amp;#10;    continueRoutine = false;&amp;#10;}&amp;#10;&amp;#10;" valType="extendedCode"/>
        <Param name="Begin Routine" updates="constant" val="# skip this component if participant &amp;#10;# wants to participate in the study&amp;#10;if expInfo['consent'] == &quot;False&quot;:&amp;#10;    continueRoutine = True&amp;#10;else: continueRoutine = False&amp;#10;&amp;#10;" valType="extendedCode"/>
        <Param name="Code Type" updates="None" val="Both" valType="str"/>
        <Param name="Each Frame" updates="constant" val="" valType="extendedCode"/>
        <Param name="Each JS Frame" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Experiment" updates="constant" val="" valType="extendedCode"/>
        <Param name="End JS Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="End Routine" updates="constant" val="" valType="extendedCode"/>
        <Param name="disabled" updates="None" val="False" valType="bool"/>
        <Param name="name" updates="None" val="skip_if_consented" valType="code"/>
      </CodeComponent>
      <TextComponent name="end1">
        <Param name="color" updates="constant" val="white" valType="color"/>
        <Param name="colorSpace" updates="constant" val="rgb" valType="str"/>
        <Param name="contrast" updates="constant" val="1" valType="num"/>
        <Param name="disabled" updates="None" val="False" valType="bool"/>
        <Param name="durationEstim" updates="None" val="" valType="code"/>
        <Param name="flip" updates="constant" val="None" valType="str"/>
        <Param name="font" updates="constant" val="Arial" valType="str"/>
        <Param name="languageStyle" updates="None" val="LTR" valType="str"/>
        <Param name="letterHeight" updates="constant" val="0.05" valType="num"/>
        <Param name="name" updates="None" val="end1" valType="code"/>
        <Param name="opacity" updates="constant" val="" valType="num"/>
        <Param name="ori" updates="constant" val="0" valType="num"/>
        <Param name="pos" updates="constant" val="(0, 0)" valType="list"/>
        <Param name="saveStartStop" updates="None" val="True" valType="bool"/>
        <Param name="startEstim" updates="None" val="" valType="code"/>
        <Param name="startType" updates="None" val="time (s)" valType="str"/>
        <Param name="startVal" updates="None" val="0.0" valType="code"/>
        <Param name="stopType" updates="None" val="duration (s)" valType="str"/>
        <Param name="stopVal" updates="constant" val="" valType="code"/>
        <Param name="syncScreenRefresh" updates="None" val="True" valType="bool"/>
        <Param name="text" updates="constant" val="Vielen Dank, Sie können dieses Fenster nun schließen!" valType="str"/>
        <Param name="units" updates="None" val="from exp settings" valType="str"/>
        <Param name="wrapWidth" updates="constant" val="" valType="num"/>
      </TextComponent>
    </Routine>
  </Routines>
  <Flow>
    <Routine name="settings"/>
    <Routine name="consent_onl"/>
    <Routine name="end_no_consent"/>
    <Routine name="demogr_onl"/>
    <Routine name="end_excluded"/>
    <Routine name="instr_1"/>
  </Flow>
</PsychoPy2experiment>
